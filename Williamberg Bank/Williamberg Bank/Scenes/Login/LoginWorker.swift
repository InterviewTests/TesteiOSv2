//
//  LoginWorker.swift
//  Williamberg Bank
//
//  Created by padrao on 16/05/20.
//  Copyright (c) 2020 Williamberg. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import SwiftKeychainWrapper

class LoginWorker
{
    
    let userKey = "user"
    let passwordKey = "password"
    
    enum UserError: LocalizedError{
        case InvalidUser
        case EmptyUser
        
        var errorDescription: String?{
            switch self {
            case .InvalidUser:
                return NSLocalizedString("Usuário inválido. Por favor, digite seu email ou cpf(somente números).", comment: "User Error")
            case .EmptyUser:
                return NSLocalizedString("O usuário não pode ser vazio", comment: "USer error")
            }
        }
    }
        
    enum PasswordError: LocalizedError{
        case NoCapitalLetter
        case NoEspecialCharacter
        case NoAlphanumericCharacter
        case EmptyPassword
        
        var errorDescription: String?{
            switch self {
            case .NoCapitalLetter:
                return NSLocalizedString("A senha deve ter pelo menos uma uma letra maiúscula.", comment: "Passaword Error")
            case .NoEspecialCharacter:
                return NSLocalizedString("A senha deve ter pelo menos um caractere especial. Por exemplo: @ ou >.", comment: "Passaword Error")
            case .NoAlphanumericCharacter:
                return NSLocalizedString("A senha deve ter pelo menos um número ou letra minúscula.", comment: "Passaword Error")
            case .EmptyPassword:
                return NSLocalizedString("A senha não pode ser vazia", comment: "Passaword Error")
            }
        }
        
    }
    
    func validadePassword(password: String?) throws{
        if let _password = password, !_password.isEmpty{
            if !existLowerAlphanumericCharacter(str: _password){
                throw PasswordError.NoAlphanumericCharacter
            }
            if !existCapitalLetter(str: _password){
                throw PasswordError.NoCapitalLetter
            }
            if !existSpecialCharacter(str: _password){
                throw PasswordError.NoEspecialCharacter
            }
        }
        else{
           throw PasswordError.EmptyPassword
        }
    }
    
    /// it checks if exists at least one capital letter on str.
    /// it returns true if exists at least one capital letter on str, it returns false otherwise.
    /// - Parameter str: An string to be checked for capital letter
    func existCapitalLetter(str: String) -> Bool{
        let capitalLetterRegEx  = ".*[A-Z]+.*"
        let result = str.range(of: capitalLetterRegEx, options: .regularExpression)
        return result != nil
    }
    
    /// it checks if exists at least one special character on str.
    /// it returns true if exists at least one special character on str, it returns false otherwise.
    /// - Parameter str: An string to be checked for special character.
    func existSpecialCharacter(str: String) -> Bool{
        let specialCharacterRex = ".*[!\"#$%&'()*+,-./:;<=>?@\\[\\\\\\]^_`{|}~]+.*"
        let result = str.range(of: specialCharacterRex, options: .regularExpression)
        return result != nil
    }
    
    /// it checks if exists at least one lower alphanumeric character on str.
    /// it returns true if exists at least one lower alphanumeric character on str, it returns false otherwise.
    /// - Parameter str: An string to be checked for lower alphanumeric character.
    func existLowerAlphanumericCharacter(str: String) -> Bool{
        let alphanumericCharacterRex = ".*[a-z0-9]+.*"
        let result = str.range(of: alphanumericCharacterRex, options: .regularExpression)
        return result != nil
    }
    
    func validateUser(user: String?) throws{
        if let _user = user, !_user.isEmpty{
            if !isValidEmail(email: _user) && !isValidCPF(cpf: _user){
                throw UserError.InvalidUser
            }
        }
        else{
            throw UserError.EmptyUser
        }
    }
    
    /// it checks if the email string parameter is a valid email.
    /// - Parameter email: the string to be checked.
    func isValidEmail(email: String) -> Bool{
        let emailRegex = "(?:[\\p{L}0-9!#$%\\&'*+/=?\\^_`{|}~-]+(?:\\.[\\p{L}0-9!#$%\\&'*+/=?\\^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[\\p{L}0-9](?:[a-z0-9-]*[\\p{L}0-9])?\\.)+[\\p{L}0-9](?:[\\p{L}0-9-]*[\\p{L}0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[\\p{L}0-9-]*[\\p{L}0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])"
        let result = email.range(of: emailRegex, options: .regularExpression)
        return result != nil
    }
    
    func isValidCPF(cpf: String) -> Bool{
        var isValid = false
        let numbers = Array(cpf).compactMap({ Int(String($0), radix: 10) })
        if numbers.count == 11 && Set(numbers).count != 1{
            isValid = numbers.prefix(9).digitoCPF == numbers[9] &&
            numbers.prefix(10).digitoCPF == numbers[10]
        }
        return isValid
    }
    
    func login(user: String, password: String, completionHandler: @escaping( _ userAccount: UserAccount?, _ errorMessage: String?) -> Void){
        
        BaseBankAPI().makeRequest(serviceName: "login", args: ["user": user, "password": password], httpMethod: .POST) { (data, response, error) in
            if let _ = error{
                DispatchQueue.main.async {
                    completionHandler(nil, "Por favor, verifique sua conexão com a internet e tente novamente.")
                }
            }
            else{
                do{
                    guard let _data = data, !_data.isEmpty else{
                        DispatchQueue.main.async {
                            completionHandler(nil, BaseBankAPI.ServiceError.NullResponse.localizedDescription)
                        }
                        return
                    }
                    let loginDTO = try JSONDecoder().decode(LoginDTO.self, from: _data)
                    DispatchQueue.main.async {
                        completionHandler(loginDTO.userAccount, loginDTO.loginServiceError?.message)
                    }
                }
                catch{
                    DispatchQueue.main.async {
                        completionHandler(nil, "erro ao formatar resposta recebida.")
                    }
                }
            }
        }
    }
    
    func saveUserOnKeychain(user:String, password: String) -> Bool{
        let savedUSer = KeychainWrapper.standard.set(user, forKey: userKey)
        let savedPassword = KeychainWrapper.standard.set(password, forKey: passwordKey)
        return savedUSer && savedPassword
    }
    
    func getUserOnKeychain() -> String?{
        return KeychainWrapper.standard.string(forKey: userKey)
    }
    
    func getUserPasswordOnKeychain() -> String?{
        return KeychainWrapper.standard.string(forKey: passwordKey)
    }
}
